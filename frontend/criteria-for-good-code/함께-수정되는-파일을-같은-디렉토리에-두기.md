# 함께 수정되는 파일을 같은 디렉토리에 두기

<div style="margin-top: 16px">
  <Badge type="info" text="좋은 코드의 기준" />
  <Badge type="info" text="응집도" />
  <Badge type="info" text="FSD(Feature-Sliced Design)" />
</div>

## 🔔 상황

보통 프로젝트에서 Hook, 컴포넌트, 유틸리티 함수 등 모듈의 종류에 따라 여러 파일을 분류하여 관리합니다.

이는 프로젝트의 크기가 커짐에 따라서 코드 사이의 의존 관계를 파악하기 어렵기 때문에 파일을 쉽게 만들고, 찾고, 삭제하는 데 어려움 줄 수 있습니다.

## 🎳 해결법

함께 수정되는 소스 파일을 하나의 디렉토리에 배치하면 코드의 의존 관계를 명확하게 드러낼 수 있습니다. 이를 통해 불필요한 참조를 방지할 뿐만 아니라, 파일을 쉽게 만들고, 찾고, 연관된 파일들을 한 번에 삭제할 수 있습니다.

## 📝 코드 예시

아래 디렉토리 구조는 프로젝트의 모든 파일을 모듈의 종류(Presentational 컴포넌트, Container 컴포넌트, Hook, 상수 등)에 따라 분류했습니다.

```text
└─ src
   ├─ components
   ├─ constants
   ├─ containers
   ├─ contexts
   ├─ remotes
   ├─ hooks
   ├─ utils
   └─ ...
```

## 👃 코드 냄새 맡아보기

파일을 모듈의 종류별로 나누면 어떤 코드가 어떤 코드를 참조하는지 쉽게 확인할 수 없습니다. 코드 파일 사이의 의존 관계는 개발자가 스스로 코드를 분석하면서 파악해야 합니다. 또한 더 이상 특정 컴포넌트나 Hook, 유틸리티 함수가 사용되지 않아서 삭제된다고 했을 때, 연관된 코드가 함께 삭제되지 못해서 사용되지 않는 코드가 남아있게 될 수도 있습니다.

프로젝트의 크기는 점점 커지기 마련인데, 프로젝트의 크기가 2배, 10배, 100배 커짐에 따라서 코드 사이의 의존관계도 크게 복잡해질 수 있습니다. 디렉토리 하나가 100개가 넘는 파일을 담고 있게 될 수도 있습니다.

## ✏️ 개선해보기

아래 디렉토리 구조는 함께 수정되는 코드 파일끼리 하나의 디렉토리를 이루도록 구조를 개선한 예시입니다.

```text
└─ src
   │  // 전체 프로젝트에서 사용되는 코드
   ├─ components
   ├─ containers
   ├─ hooks
   ├─ utils
   ├─ ...
   │
   └─ domains
      │  // Domain1에서만 사용되는 코드
      ├─ Domain1
      │     ├─ components
      │     ├─ containers
      │     ├─ hooks
      │     ├─ utils
      │     └─ ...
      │
      │  // Domain2에서만 사용되는 코드
      └─ Domain2
            ├─ components
            ├─ containers
            ├─ hooks
            ├─ utils
            └─ ...
```

함께 수정되는 코드 파일을 하나의 디렉토리 아래에 둔다면, 코드 사이의 의존 관계를 파악하기 쉽습니다.

예를 들어, 다음과 같이 한 도메인(`Domain1`)의 하위 코드에서 다른 도메인(`Domain2`)의 소스 코드를 참조한다고 생각해 봅시다.

```typescript
import { useFoo } from "../../../Domain2/hooks/useFoo";
```

이런 import 문을 만난다면 잘못된 파일을 참조하고 있다는 것을 쉽게 인지할 수 있습니다.

또한, 특정 기능과 관련된 코드를 삭제할 때 한 디렉토리 전체를 삭제하면 깔끔하게 모든 코드가 삭제되므로, 프로젝트 내부에 더 이상 사용되지 않는 코드가 없도록 할 수 있습니다.

## 🔍 더 알아보기: FSD(Feature-Sliced Design)

Feature-Sliced Design (FSD)는 프론트엔드 애플리케이션의 구조를 잡는 아키텍처 방법론입니다. 이 방법론의 주요 목적은 계속 변화하는 비즈니스 요구사항에 직면했을 때 프로젝트를 더 이해하기 쉽고 안정적으로 만드는 것입니다.

### 장점

- **균일성**: 구조가 표준화되어 있기 때문에 일관성 있는 프로젝트가 됩니다. 새로운 멤버가 팀에 적응하는 것을 더 쉽게 만듭니다.
- **변경과 리팩토링에 대한 안정성**: 한 레이어의 구성 요소는 같은 레이어나 상위 레이어의 다른 구성 요소를 사용할 수 없습니다. 코드를 수정했을 때 변경에 따른 범위를 예측할 수 있습니다.
- **로직 재사용을 통제**: 레이어에 따라 코드를 재사용 가능하게 또는 지역적으로 만들 수 있습니다. 이는 DRY(Do not Repeat Yourself) 원칙과 실용성(중복 코드 허용) 사이의 균형을 유지합니다.
- **비즈니스와 사용자 요구에 대한 지향성**: 앱은 비즈니스 도메인으로 분할되며, 이름을 지을 때 비즈니스 언어 사용이 권장됩니다. 프로젝트의 모든 기능을 몰라도 특정 도메인 내에서 효율적으로 개발할 수 있습니다.

### 계층 구조

레이어, 슬라이스, 세그먼트는 다음과 같은 계층 구조를 형성합니다:
![](./assets/fsd-hierarchy.jpg)

#### 레이어

모든 레이어를 사용할 필요는 없지만, 이름은 중요합니다. 현재(위에서 아래로) 7개가 있습니다:

1. **App**: 앱을 실행하는 모든 것, 예를 들어 라우팅, 진입점, 전역 스타일, 프로바이더.
2. **Pages**: 전체 페이지 또는 중첩 라우팅에서 페이지의 주요 부분.
3. **Widgets**: 독립적으로 작동하는 대규모 기능 또는 UI 컴포넌트, 보통 하나의 완전한 기능.
4. **Features**: 제품 전반에 걸쳐 재사용되는 기능 구현체로, 사용자에게 실질적인 비즈니스 가치를 제공하는 동작.
5. **Entities**: 프로젝트가 다루는 비즈니스 엔티티, 예를 들어 user 또는 product.
6. **Shared**: 재사용 가능한 기능.

:::info
다른 레이어들과 달리 App과 Shared는 슬라이스를 가지지 않으며, 직접 세그먼트로 구성됩니다.
:::

레이어를 다룰 때의 중요한 점은 한 레이어의 구성 요소는 반드시 아래에 있는 레이어의 구성 요소만 임포트할 수 있다는 것입니다.

#### 슬라이스

슬라이스는 비즈니스 도메인별로 코드를 분할합니다. 슬라이스는 함께 수정되는 소스 파일들을 가까이 둠으로써 파일을 쉽게 만들고, 찾고, 연관된 파일들을 한 번에 삭제할 수 있습니다.

#### 세그먼트

슬라이스와 App, Shared 레이어는 세그먼트로 구성되며, 세그먼트는 모듈의 종류에 따라 여러 파일을 분류하여 관리합니다.

```text
└─ entities
   └─ product
      ├─ components
      ├─ containers
      ├─ hooks
      ├─ utils
      └─ ...
```
